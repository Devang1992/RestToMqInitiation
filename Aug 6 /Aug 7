// 1-based line numbers
private static final int PAGE_LINES = 65;
private static final int CONTENT_LAST_LINE = 62;
private static final int LINE_ID_LINE = 1;
private static final int FIRST_PAGE_HASH_LINE = 2;
private static final int FIRST_PAGE_ADDRESS_START = 17;
private static final int NEXT_PAGE_ADDRESS_START = 8;
private static final int PAGE_NUMBER_LINE = 65;
private static final int LINE_LENGTH = 133;

private static String pad(String s) { return String.format("%-" + LINE_LENGTH + "s", s); }

public void generateFile(List<String> renderedMessages, Path outputPath) {
    List<String> finalOutput = new ArrayList<>();
    finalOutput.add(templateMapper.getBannerPage()); // your banner (already padded)

    int docCounter = 1;
    for (String message : renderedMessages) {
        // split message into content + address block (you already have these two lists)
        List<String> contentLines = extractContentLines(message);
        List<String> addressBlock = extractAddressBlock(message);

        int idx = 0; // index into contentLines
        boolean firstPage = true;

        while (idx < contentLines.size()) {
            List<String> page = blankPage();

            // common header
            page.set(LINE_ID_LINE - 1, pad("1"));

            int addressStart = firstPage ? FIRST_PAGE_ADDRESS_START : NEXT_PAGE_ADDRESS_START;

            if (firstPage) {
                page.set(FIRST_PAGE_HASH_LINE - 1, pad("#"));
            }

            // place address block
            int aLine = addressStart;
            for (String addr : addressBlock) {
                if (aLine > CONTENT_LAST_LINE) break; // hard stop
                page.set(aLine - 1, pad(addr));
                aLine++;
            }

            // compute where content is allowed to start
            int contentStart = addressStart + addressBlock.size();
            if (contentStart < (firstPage ? FIRST_PAGE_HASH_LINE + 1 : LINE_ID_LINE + 1)) {
                // just in case addressBlock is empty, ensure we don't overwrite header
                contentStart = (firstPage ? FIRST_PAGE_HASH_LINE + 1 : LINE_ID_LINE + 1);
            }

            // write content up to line 62
            int linePtr = Math.max(contentStart, (firstPage ? FIRST_PAGE_HASH_LINE + 1 : LINE_ID_LINE + 1));
            while (idx < contentLines.size() && linePtr <= CONTENT_LAST_LINE) {
                page.set(linePtr - 1, pad(contentLines.get(idx++)));
                linePtr++;
            }

            // blank 63-64 are already blank in blankPage()

            // page footer
            page.set(PAGE_NUMBER_LINE - 1, pad(String.format("Page %02d", docCounter)));
            docCounter++;

            finalOutput.add(String.join("\r\n", page));
            firstPage = false;
        }
    }

    try {
        Files.writeString(
                outputPath,
                String.join("\r\n", finalOutput) + "\r\n",
                StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING
        );
    } catch (IOException e) {
        throw new RuntimeException("Error writing batch file", e);
    }
}

private List<String> blankPage() {
    List<String> page = new ArrayList<>(Collections.nCopies(PAGE_LINES, pad("")));
    return page;
}
