for (String message : renderedMessages) {

    int pageCounter = 1; // ✅ Reset for each message

    List<String> contentLines = extractContentLines(message);
    List<String> addressBlock = extractAddressBlock(message);

    boolean firstPage = true;
    int idx = 0;

    while (idx < contentLines.size()) {
        List<String> page = blankPage();

        // header
        page.set(LINE_ID_LINE - 1, pad("1"));
        if (firstPage) {
            page.set(FIRST_PAGE_HASH_LINE - 1, pad("#"));
        }

        // address
        int addressStart = firstPage ? FIRST_PAGE_ADDRESS_START : NEXT_PAGE_ADDRESS_START;
        int aLine = addressStart;
        for (String addr : addressBlock) {
            if (aLine > CONTENT_LAST_LINE) break;
            page.set(aLine - 1, pad(addr));
            aLine++;
        }

        // content
        int contentStart = addressStart + addressBlock.size();
        if (contentStart <= (firstPage ? FIRST_PAGE_HASH_LINE : LINE_ID_LINE)) {
            contentStart = (firstPage ? FIRST_PAGE_HASH_LINE + 1 : LINE_ID_LINE + 1);
        }

        int linePtr = contentStart;
        while (idx < contentLines.size() && linePtr <= CONTENT_LAST_LINE) {
            page.set(linePtr - 1, pad(contentLines.get(idx++)));
            linePtr++;
        }

        // page number footer
        page.set(PAGE_NUMBER_LINE - 1, pad(String.format("Page %02d", pageCounter)));
        pageCounter++; // ✅ Only increments inside the same message

        finalOutput.add(String.join("\r\n", page));

        firstPage = false;
    }
}


--------

private List<String> extractAddressBlock(String message) {
    List<String> addressBlock = new ArrayList<>();
    String[] lines = message.split("\\r?\\n");

    for (String line : lines) {
        if (line.trim().isEmpty()) {
            break; // stop at the first blank line
        }
        addressBlock.add(line);
    }
    return addressBlock;
}

private List<String> extractContentLines(String message) {
    List<String> contentLines = new ArrayList<>();
    String[] lines = message.split("\\r?\\n");

    boolean addressEnded = false;
    for (String line : lines) {
        if (!addressEnded) {
            if (line.trim().isEmpty()) {
                addressEnded = true; // now start capturing content
            }
        } else {
            contentLines.add(line);
        }
    }
    return contentLines;
}
Example
If message is:

------------

// 1-based line numbers
private static final int PAGE_LINES = 65;
private static final int CONTENT_LAST_LINE = 62;
private static final int LINE_ID_LINE = 1;
private static final int FIRST_PAGE_HASH_LINE = 2;
private static final int FIRST_PAGE_ADDRESS_START = 17;
private static final int NEXT_PAGE_ADDRESS_START = 8;
private static final int PAGE_NUMBER_LINE = 65;
private static final int LINE_LENGTH = 133;

private static String pad(String s) { return String.format("%-" + LINE_LENGTH + "s", s); }

public void generateFile(List<String> renderedMessages, Path outputPath) {
    List<String> finalOutput = new ArrayList<>();
    finalOutput.add(templateMapper.getBannerPage()); // your banner (already padded)

    int docCounter = 1;
    for (String message : renderedMessages) {
        // split message into content + address block (you already have these two lists)
        List<String> contentLines = extractContentLines(message);
        List<String> addressBlock = extractAddressBlock(message);

        int idx = 0; // index into contentLines
        boolean firstPage = true;

        while (idx < contentLines.size()) {
            List<String> page = blankPage();

            // common header
            page.set(LINE_ID_LINE - 1, pad("1"));

            int addressStart = firstPage ? FIRST_PAGE_ADDRESS_START : NEXT_PAGE_ADDRESS_START;

            if (firstPage) {
                page.set(FIRST_PAGE_HASH_LINE - 1, pad("#"));
            }

            // place address block
            int aLine = addressStart;
            for (String addr : addressBlock) {
                if (aLine > CONTENT_LAST_LINE) break; // hard stop
                page.set(aLine - 1, pad(addr));
                aLine++;
            }

            // compute where content is allowed to start
            int contentStart = addressStart + addressBlock.size();
            if (contentStart < (firstPage ? FIRST_PAGE_HASH_LINE + 1 : LINE_ID_LINE + 1)) {
                // just in case addressBlock is empty, ensure we don't overwrite header
                contentStart = (firstPage ? FIRST_PAGE_HASH_LINE + 1 : LINE_ID_LINE + 1);
            }

            // write content up to line 62
            int linePtr = Math.max(contentStart, (firstPage ? FIRST_PAGE_HASH_LINE + 1 : LINE_ID_LINE + 1));
            while (idx < contentLines.size() && linePtr <= CONTENT_LAST_LINE) {
                page.set(linePtr - 1, pad(contentLines.get(idx++)));
                linePtr++;
            }

            // blank 63-64 are already blank in blankPage()

            // page footer
            page.set(PAGE_NUMBER_LINE - 1, pad(String.format("Page %02d", docCounter)));
            docCounter++;

            finalOutput.add(String.join("\r\n", page));
            firstPage = false;
        }
    }

    try {
        Files.writeString(
                outputPath,
                String.join("\r\n", finalOutput) + "\r\n",
                StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING
        );
    } catch (IOException e) {
        throw new RuntimeException("Error writing batch file", e);
    }
}

private List<String> blankPage() {
    List<String> page = new ArrayList<>(Collections.nCopies(PAGE_LINES, pad("")));
    return page;
}
